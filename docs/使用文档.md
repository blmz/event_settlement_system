# 事件结算系统使用文档

## 目录
1. [简介](#简介)
2. [核心概念](#核心概念)
3. [快速开始](#快速开始)
4. [核心API](#核心API)
5. [高级用法](#高级用法)
6. [最佳实践](#最佳实践)
7. [示例代码](#示例代码)

---

## 简介

事件结算系统（Event Settlement System）是一个通用的数值管线结算插件，用于处理游戏中各种事件驱动的数值计算。

### 主要特性
- 灵活的修改器系统：支持加法、乘法、覆盖和自定义修改
- 优先级控制：修改器按优先级顺序执行
- 条件判断：修改器可以根据条件选择性应用
- 多阶段处理：事件处理分为多个阶段，便于插入逻辑
- 完整的历史记录：追踪所有数值变化
- 信号系统：支持事件监听和响应

### 适用场景
- 战斗系统（伤害、治疗、暴击计算）
- 增益/减益效果管理
- 属性修改和计算
- 技能效果结算
- 经济系统（货币、经验值）

---

## 核心概念

### 1. EventData（事件数据）
存储事件的所有信息，包括：
- **event_type**：事件类型（如"damage"、"heal"）
- **source**：事件发起者
- **target**：事件目标
- **base_value**：基础数值
- **final_value**：最终数值（经过修改器处理）
- **extra_data**：额外数据字典

### 2. EventModifier（事件修改器）
修改事件数值的核心组件，包含：
- **modifier_name**：修改器名称
- **priority**：优先级（越大越先执行）
- **modifier_type**：修改类型（ADD/MULTIPLY/OVERRIDE/CUSTOM）
- **value**：修改值
- **condition_func**：条件函数

### 3. EventSettlementManager（结算管理器）
单例管理器，负责：
- 注册和管理事件类型
- 管理全局和局部修改器
- 处理事件结算流程
- 发送事件信号

---

## 快速开始

### 步骤1：启用插件
1. 打开 Godot 编辑器
2. 进入 `项目 → 项目设置 → 插件`
3. 找到"事件结算系统"并启用

### 步骤2：创建简单事件

```gdscript
# 创建伤害事件
var damage_event = EventData.new("damage", attacker, defender, 100.0)

# 处理事件
var result = EventSettlementManager.process_event(damage_event)

# 获取最终伤害
print("最终伤害: ", result.final_value)
```

### 步骤3：添加修改器

```gdscript
# 创建+50伤害的修改器
var bonus_damage = EventModifier.create_add_modifier("伤害加成", 50.0, 100)

# 添加到伤害事件
EventSettlementManager.add_event_modifier("damage", bonus_damage)
```

---

## 核心API

### EventSettlementManager（单例）

#### 注册事件类型
```gdscript
EventSettlementManager.register_event_type("damage", "伤害事件")
EventSettlementManager.register_event_type("heal", "治疗事件")
```

#### 添加修改器
```gdscript
# 添加全局修改器（对所有事件生效）
EventSettlementManager.add_global_modifier(modifier)

# 添加特定事件类型的修改器
EventSettlementManager.add_event_modifier("damage", modifier)
```

#### 处理事件
```gdscript
var result = EventSettlementManager.process_event(event_data)
```

#### 移除修改器
```gdscript
EventSettlementManager.remove_modifier(modifier)
```

#### 清空所有修改器
```gdscript
EventSettlementManager.clear_all_modifiers()
```

### EventData（事件数据）

#### 创建事件
```gdscript
var event = EventData.new("damage", source, target, 100.0)
```

#### 设置/获取额外数据
```gdscript
event.set_extra("damage_type", "physical")
var damage_type = event.get_extra("damage_type", "normal")
```

#### 获取数值变化历史
```gdscript
print(event.get_value_changes())
```

### EventModifier（修改器）

#### 创建不同类型的修改器
```gdscript
# 加法修改器
var add_mod = EventModifier.create_add_modifier("名称", 50.0, 优先级)

# 乘法修改器
var mult_mod = EventModifier.create_multiply_modifier("名称", 1.5, 优先级)

# 覆盖修改器
var override_mod = EventModifier.create_override_modifier("名称", 200.0, 优先级)

# 自定义修改器
var custom_mod = EventModifier.create_custom_modifier("名称", func(event_data):
    event_data.final_value = event_data.final_value * 2.0
, 优先级)
```

#### 设置条件
```gdscript
modifier.set_condition(func(event_data: EventData) -> bool:
    return event_data.final_value > 100.0
)
```

### EventUtils（工具类）

#### 快速创建常见事件
```gdscript
# 伤害事件
var damage = EventUtils.create_damage_event(source, target, 100.0, "physical")

# 治疗事件
var heal = EventUtils.create_heal_event(source, target, 50.0)

# 增益事件
var buff = EventUtils.create_buff_event(source, target, "attack_boost", 10.0)
```

#### 常用条件函数
```gdscript
# 检查事件类型
var condition = EventUtils.condition_event_type(["damage", "heal"])

# 检查数值范围
var condition = EventUtils.condition_value_in_range(50.0, 200.0)

# 随机触发（30%概率）
var condition = EventUtils.condition_random_chance(0.3)

# 检查额外数据
var condition = EventUtils.condition_has_extra_data("damage_type", "fire")

# 组合条件（与）
var condition = EventUtils.condition_and([condition1, condition2])
```

---

## 高级用法

### 1. 使用管线系统

```gdscript
# 创建结算管线
var pipeline = SettlementPipeline.new("伤害计算管线")

# 添加阶段
pipeline.add_stage(SettlementPipeline.PipelineStage.new(
    "基础伤害",
    10,
    func(event_data): event_data.final_value *= 1.0
))

pipeline.add_stage(SettlementPipeline.PipelineStage.new(
    "防御计算",
    20,
    func(event_data): 
        var defense = event_data.target.defense
        event_data.final_value = max(0, event_data.final_value - defense)
))

# 执行管线
var result = pipeline.execute(event_data)
```

### 2. 监听事件信号

```gdscript
func _ready():
    # 监听事件结算信号
    EventSettlementManager.event_settled.connect(_on_event_settled)
    
    # 监听事件处理前
    EventSettlementManager.event_before_process.connect(_on_before_process)

func _on_event_settled(event_data: EventData):
    print("事件已结算: ", event_data.event_type)

func _on_before_process(event_data: EventData):
    # 在事件处理前添加临时修改器
    if event_data.event_type == "damage":
        var temp_mod = EventModifier.create_multiply_modifier("临时加成", 1.2)
        EventSettlementManager.add_event_modifier("damage", temp_mod)
```

### 3. 复杂条件修改器

```gdscript
# 创建复杂条件的修改器
var critical_hit = EventModifier.create_multiply_modifier("暴击", 2.0, 200)

# 设置多条件
critical_hit.set_condition(
    EventUtils.condition_and([
        EventUtils.condition_event_type(["damage"]),
        EventUtils.condition_random_chance(0.15),  # 15%暴击率
        func(event_data: EventData) -> bool:
            # 自定义条件：目标不是Boss
            return not event_data.target.has_tag("boss")
    ])
)

EventSettlementManager.add_event_modifier("damage", critical_hit)
```

### 4. 动态修改器管理

```gdscript
class_name BuffSystem extends Node

var active_buffs: Dictionary = {}

func apply_buff(target: Node, buff_id: String, duration: float):
    # 创建增益修改器
    var buff_modifier = EventModifier.create_multiply_modifier(
        "Buff_%s" % buff_id,
        1.3,
        50
    )
    
    # 设置条件：只对特定目标生效
    buff_modifier.set_condition(func(event_data: EventData) -> bool:
        return event_data.target == target
    )
    
    # 添加修改器
    EventSettlementManager.add_global_modifier(buff_modifier)
    active_buffs[buff_id] = buff_modifier
    
    # 定时移除
    await get_tree().create_timer(duration).timeout
    remove_buff(buff_id)

func remove_buff(buff_id: String):
    if active_buffs.has(buff_id):
        EventSettlementManager.remove_modifier(active_buffs[buff_id])
        active_buffs.erase(buff_id)
```

---

## 最佳实践

### 1. 优先级设计
- **1000+**：游戏规则级修改（无敌、免疫）
- **500-999**：暴击、穿透等重要修改
- **100-499**：增益/减益效果
- **1-99**：基础属性加成
- **负数**：最终伤害减免

### 2. 命名规范
```gdscript
# 使用描述性名称
var good_name = EventModifier.create_add_modifier("火焰伤害加成", 50.0)
var bad_name = EventModifier.create_add_modifier("mod1", 50.0)  # ❌

# 使用事件类型常量
const EVENT_DAMAGE = "damage"
const EVENT_HEAL = "heal"
```

### 3. 性能优化
```gdscript
# 避免在修改器中进行重复计算
# ❌ 不好的做法
modifier.set_condition(func(event_data):
    var expensive_calculation = calculate_something_heavy()
    return expensive_calculation > 100
)

# 推荐做法
var cached_value = calculate_something_heavy()
modifier.set_condition(func(event_data):
    return cached_value > 100
)
```

### 4. 调试技巧
```gdscript
# 使用工具函数打印详情
EventUtils.print_event_details(event_data)

# 检查修改历史
print(event_data.get_value_changes())

# 启用详细日志
EventSettlementManager.event_processing.connect(func(event_data):
    print("处理事件: ", event_data.event_type, " 当前值: ", event_data.final_value)
)
```

---

## 示例代码

### 完整的战斗系统示例

```gdscript
extends Node

class_name CombatSystem

func _ready():
    setup_combat_system()

func setup_combat_system():
    # 注册事件类型
    EventSettlementManager.register_event_type("damage", "伤害")
    EventSettlementManager.register_event_type("heal", "治疗")
    
    # 设置全局护甲减伤
    var armor_reduction = EventModifier.create_custom_modifier(
        "护甲减伤",
        func(event_data: EventData):
            if event_data.event_type == "damage" and event_data.target:
                var armor = event_data.target.get("armor", 0)
                var reduction = armor / (armor + 100.0)
                event_data.final_value *= (1.0 - reduction),
        100
    )
    EventSettlementManager.add_global_modifier(armor_reduction)
    
    # 设置暴击系统
    var critical_hit = EventModifier.create_multiply_modifier("暴击", 2.0, 200)
    critical_hit.set_condition(func(event_data: EventData) -> bool:
        if event_data.source == null:
            return false
        var crit_chance = event_data.source.get("crit_chance", 0.0)
        return randf() < crit_chance
    )
    EventSettlementManager.add_event_modifier("damage", critical_hit)

func deal_damage(attacker: Node, defender: Node, base_damage: float) -> float:
    # 创建伤害事件
    var damage_event = EventUtils.create_damage_event(
        attacker, 
        defender, 
        base_damage,
        "physical"
    )
    
    # 处理事件
    var result = EventSettlementManager.process_event(damage_event)
    
    # 应用伤害
    if defender.has_method("take_damage"):
        defender.take_damage(result.final_value)
    
    # 显示伤害信息
    show_damage_number(defender, result.final_value, result.modifier_history)
    
    return result.final_value

func show_damage_number(target: Node, damage: float, history: Array):
    var text = "%.0f" % damage
    
    # 检查是否暴击
    for record in history:
        if record.modifier == "暴击":
            text = "暴击! " + text
            break
    
    # 显示伤害数字（需要实现DamageNumberDisplay）
    print("显示伤害: ", text, " 于 ", target.name)
```

---

## 常见问题

### Q: 如何实现护盾系统？
```gdscript
var shield_modifier = EventModifier.create_custom_modifier(
    "护盾吸收",
    func(event_data: EventData):
        if event_data.event_type == "damage":
            var shield = event_data.target.get("shield", 0)
            if shield > 0:
                var absorbed = min(shield, event_data.final_value)
                event_data.final_value -= absorbed
                event_data.target.shield -= absorbed
                event_data.set_extra("shield_absorbed", absorbed),
    1000  # 高优先级，最先处理
)
```

### Q: 如何实现伤害类型克制？
```gdscript
var type_advantage = EventModifier.create_custom_modifier(
    "属性克制",
    func(event_data: EventData):
        var attacker_type = event_data.get_extra("damage_type", "normal")
        var defender_type = event_data.target.get("element_type", "normal")
        
        # 火克草
        if attacker_type == "fire" and defender_type == "grass":
            event_data.final_value *= 2.0
        # 水克火
        elif attacker_type == "water" and defender_type == "fire":
            event_data.final_value *= 2.0,
    150
)
```

---

## 更新日志

### v1.0.0 (当前版本)
- 基础事件系统
- 修改器系统
- 管线处理
- 工具函数库
- 示例场景

---

## 技术支持

如有问题或建议，请访问：
- GitHub: [项目地址]
- 文档: [在线文档]
- 讨论区: [社区论坛]

---

**© 2026 事件结算系统 | Godot 4.6+**
